package com.ru.usty.elevator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class Elevator implements Runnable {

	private ArrayList<Person> passengers = new ArrayList<Person>();
	private int numPassengers;
	private int currentFloor;
	private int capacity;
	private int ID;
	private int numFloors;
	private Thread thread;
	private ElevatorScene scene;
	private Semaphore semaphore = new Semaphore(1);
	Map<Integer, Integer> wantedFloors = new HashMap<Integer, Integer>();
	private String direction = "up";
	
	public Elevator(int id, int numFloors, int capacity, ElevatorScene scene) {
		this.currentFloor = 0;
		this.capacity = capacity;
		this.ID = id;
		this.numFloors = numFloors - 1;
		this.thread = new Thread(this, "" + this.ID);
		this.scene = scene;
	}
	
	@Override
	public void run() {
		
		while(true) {
			// Open door
			boolean permit = true;
		    try {
		        permit = semaphore.tryAcquire(1, TimeUnit.SECONDS);
		        if (permit) {
		            letOnPassengers();
		            if (scene.getPeople().size() != 0) {
			            System.out.println("Let on " + numPassengers + " passengers at the " + currentFloor + " floor. " + scene.getPeople().size() + " are left waiting.");
		            }
		            moveFloors();
		            Thread.sleep(5);
		        } else {
		            System.out.println("Could not acquire semaphore");
		        }
		    } catch (InterruptedException e) {
		        throw new IllegalStateException(e);
		    } finally {
		        if (permit) {
		        	letOutPassengers();
		            semaphore.release();
		        }
		    }
		}
	}
	
	private void letOnPassengers() {
		ArrayList<Person> people = scene.getPeopleAtFloor(currentFloor);
        for (Person person : people) {
        	if (numPassengers < capacity) {
            	numPassengers++;
            	passengers.add(person);
            	int floor = person.getStopFloor();
            	if (wantedFloors.containsKey(floor)) {
            		wantedFloors.replace(floor, wantedFloors.get(floor) + 1);
            	} else {
            		wantedFloors.put(floor, 0);
            	}
            	
        	}
        }
	}
	
	private void letOutPassengers() {
		for (int i = numPassengers - 1; i >= 0; i--){
    		if (passengers.get(i).getStopFloor() == currentFloor) {
        		scene.personExitsAtFloor(currentFloor);
	        	wantedFloors.put(currentFloor, wantedFloors.get(currentFloor) - 1);
        		passengers.get(i).stopRunning();
        		scene.removePerson(passengers.get(i));
    			numPassengers--;
    			passengers.remove(i);
    		}
    	}
		
	}
	
	private void moveFloors() {
		int newFloor = currentFloor;
		int moveNumFloors = 1;
		
		if (currentFloor == numFloors) {
			direction = "down";
			newFloor = currentFloor - 1;
		} else if (currentFloor == 0){
			direction = "up";
			newFloor = currentFloor + 1;
		}
		
//		if (wantedFloors.get(newFloor - 1) != null) {
//			int wantedFloor = wantedFloors.get(newFloor - 1);
//			while (scene.getNumberOfPeopleWaitingAtFloor(wantedFloor) == 0 && wantedFloor == 0) {
//				moveNumFloors += 1;
//			}
//		} 
//		
//		if (wantedFloors.get(newFloor + 1) != null) {
//			int wantedFloor = wantedFloors.get(newFloor + 1);
//			while (scene.getNumberOfPeopleWaitingAtFloor(wantedFloor) == 0 && wantedFloor == 0) {
//				moveNumFloors += 1;
//			}
//		}
		
		while (scene.getNumberOfPeopleWaitingAtFloor(newFloor) == 0 && wantedFloors.get(newFloor) == 0 && scene.getPeople().size() != 0) {
			moveNumFloors += 1;
			if (newFloor == numFloors) {
				direction = "down";
				moveNumFloors = 1;
			}
			if (direction == "up") {
				newFloor += 1;
			} else {
				newFloor -= 1;
			}
		}
		
		if (direction == "up") {
			currentFloor += moveNumFloors;
		} else {
			currentFloor -= moveNumFloors;
		}
	}
	
	public void letPersonOn(Person person) {
		passengers.add(person);
	}
	
	public boolean isFull() {
		return passengers.size() == this.capacity;
	}
	
	public int getNumPassengers() {
		return this.passengers.size();
	}
	
	public int getCurrentFloor() {
		return this.currentFloor;
	}

	public int getElevatorId() {
		return this.ID;
	}
	
    public Thread getThread(){
        return this.thread;
    }

    public synchronized boolean enter(int riderId){
        this.numPassengers++;
        return true;
    }
	
	

}
